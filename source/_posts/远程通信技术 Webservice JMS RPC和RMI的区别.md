---
title: 远程通信技术 Webservice JMS RPC和RMI的区别
date: 2019-09-29 19:40:20
tags:
- Webservice
- RPC
- RMI
- JMS
---

# 远程通信技术 Webservice JMS RPC和RMI的区别
 
------
 
## 一、RMI 远程方法调用

RMI（Remote Method Invocation）远程方法调用。能够让在客户端Java虚拟机上的对象像调用本地对象一样调用服务端java 虚拟机中的对象上的方法。使用代表：EJB

#### RMI远方法程调用步骤： 

 * 1、客户调用客户端辅助对象stub上的方法
 * 2、客户端辅助对象stub打包调用信息（变量、方法名），通过网络发送给服务端辅助对象skeleton
 * 3、服务端辅助对象skeleton将客户端辅助对象发送来的信息解包，找出真正被调用的方法以及该方法所在对象
 * 4、调用真正服务对象上的真正方法，并将结果返回给服务端辅助对象skeleton
 * 5、服务端辅助对象将结果打包，发送给客户端辅助对象stub
 * 6、客户端辅助对象将返回值解包，返回给调用者
 * 7、客户获得返回值

## 二、RPC 远程过程调用

RPC（Remote Procedure Call Protocol）远程过程调用协议，通过网络从远程计算机上请求调用某种服务。它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。 使用代表：Dubbo
一次RPC调用的过程大概有10步： 
 * 1、执行客户端调用语句，传送参数
 * 2、调用本地系统发送网络消息
 * 3、消息传送到远程主机
 * 4、服务器得到消息并取得参数 
 * 5、根据调用请求以及参数执行远程过程（服务）
 * 6、执行过程完毕，将结果返回服务器句柄
 * 7、服务器句柄返回结果，调用远程主机的系统网络服务发送结果
 * 8、消息传回本地主机 
 * 9、客户端句柄由本地主机的网络服务接收消息
 * 10、客户端接收到调用语句返回的结果数据
>
## 三、RMI与RPC的区别

 * 1、方法调用方式不同： 
RMI调用方法，RMI中是通过在客户端的Stub对象作为远程接口进行远程方法的调用。每个远程方法都具有方法签名。如果一个方法在服务器上执行，但是没有相匹配的签名被添加到这个远程接口(stub)上，那么这个新方法就不能被RMI客户方所调用。
RPC调用函数，RPC中是通过网络服务协议向远程主机发送请求，请求包含了一个参数集和一个文本值，通常形成“classname.methodname(参数集)”的形式。这就向RPC服务器表明，被请求的方法在“classname”的类中，名叫“methodname”。然后RPC服务器就去搜索与之相匹配的类和方法，并把它作为那种方法参数类型的输入。这里的参数类型是与RPC请求中的类型是匹配的。一旦匹配成功，这个方法就被调用了，其结果被编码后通过网络协议发回。
 * 2、适用语言范围不同： 
RMI只用于Java，支持传输对象。
RPC是基于C语言的，不支持传输对象，是网络服务协议，与操作系统和语言无关。
 * 3、调用结果的返回形式不同： 
RMI是面向对象的，Java是面向对象的，所以RMI的调用结果可以是对象类型或者基本数据类型。
RPC的结果统一由外部数据表示(External Data Representation,XDR)语言表示，这种语言抽象了字节序类和数据类型结构之间的差异。只有由XDR定义的数据类型才能被传递，可以说RMI是面向对象方式的Java RPC。

#### 四、附录
 * RPC（Remote Procedure Call Protocol）远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC不依赖于具体的网络传输协议，tcp、udp等都可以。
由于存在各式各样的变换和细节差异，相应的RPC也派生出了各式远程过程通信协议。RPC是跨语言的通信标准，SUN和微软都有其实现，比如：RMI可以被看作SUN对RPC的Java版本（实现），而微软的DCOM就是建立在ORPC协议之上。
一言以蔽之，RPC是协议，而无论是SUN的RMI还是微软的DCOM都是对该协议的不同实现，二者都为编程人员提供了应用PRC技术的程序接口（API）。
 * RMI是Java的一组拥护开发分布式应用程序的API。RMI使用Java语言接口定义了远程对象，它集合了Java序列化和Java远程方法协议(Java Remote Method Protocol)。简单地说，这样使原先的程序在同一操作系统的方法调用，变成了不同操作系统之间程序的方法调用，由于J2EE是分布式程序平台，它以RMI机制实现了程序组件在不同操作系统之间的通信。
比如，一个EJB可以通过RMI调用Web上另一台机器上的EJB远程方法。
RMI（Remote Method Invocation，远程方法调用）是用Java在JDK1.1中实现的，它大大增强了Java开发分布式应用的能力。

 * Java作为一种风靡一时的网络开发语言，其巨大的威力就体现在它强大的开发分布式网络应用的能力上，而RMI就是开发百分之百纯Java的网络分布式应用系统的核心解决方案之一。其实RMI可以被看作是RPC的Java版本（实现）。
传统RPC并不能很好地应用于分布式对象系统，而Java RMI 则支持存储于不同地址空间的程序级对象之间彼此进行通信，实现远程对象之间的无缝远程调用。
RMI目前使用Java远程消息交换协议（JRMP，Java Remote Messaging Protocol）进行通信。JRMP是专为Java的远程对象制定的协议。因此，Java RMI具有Java的“Write Once，Run Anywhere”的优点，是分布式应用系统的百分之百纯Java解决方案。用Java RMI开发的应用系统可以部署在任何支持JRE（Java Run Environment Java，Java运行环境）的平台上。但由于JRMP是专为Java对象制定的，因此，RMI对于用非Java语言开发的应用系统的支持不足。不能与用非Java语言书写的对象进行通信。

 * Hadoop作为一个存储与服务的基础性平台，同时它的内部有采用了master/slave架构，那么其内部通信和与客户端的交互就是必不可少的了。Hadoop在实现时抛弃了JDK自带的一个RPC实现--RMI，而自己基于IPC模型实现了一个更高效的轻量级RPC。

 * RMI的局限性之一：RMI对服务器的IP地址和端口依赖很紧密，但是在开发的时候不知道将来的服务器IP和端口如何，但是客户端程序依赖这个IP和端口。这个问题有两种解决途径：一是通过DNS来解决，二是通过封装将IP暴露到程序代码之外。注意：我们在实际开发中，我们是知道服务器IP和端口的。
RMI的局限性之二：是RMI是Java语言的远程调用，两端的程序语言必须是Java实现，对于不同语言间的通讯可以考虑用WebService或者公用对象请求代理体系（CORBA）来实现。

 * 3、JMS：Java 消息服务(Java Messaging Service) 是一种允许应用程序创建、发送、接受和读取消息的Java API。JMS 在其中扮演的角色与JDBC 很相似，正如 JDBC 提供了一套用于访问各种不同关系数据库的公共API，JMS 也提供了独立于特定厂商的企业消息系统访问方式。 
使用JMS 的应用程序被称为JMS客户端，处理消息路由与传递的消息系统被称为 JMS Provider，而JMS 应用则是由多个JMS 客户端和一个 JMS Provider 构成的业务系统。发送消息的JMS 客户端被称为生产者(producer)，而接收消息的JMS 客户端则被称为消费者(consumer)。同一JMS 客户端既可以是生产者也可以是消费者。
JMS 的编程过程很简单，概括为：应用程序A 发送一条消息到消息服务器(也就是JMS Provider)的某个目的地(Destination)，然后消息服务器把消息转发给应用程序B。因为应用程序A 和应用程序B 没有直接的代码关连，所以两者实现了解偶。
***
 * RMI和JMS的区别：
     * 1、传输方式上 
JMS 与 RMI 的区别在于：采用 JMS 服务，对象是在物理上被异步从网络的某个 JVM 上直接移动到另一个 JVM 上（是消息通知机制）。
RMI 对象是绑定在本地 JVM 中，只有函数参数和返回值是通过网络传送的（是请求应答机制）。
     * 2、方法调用上 
RMI 一般都是同步的，也就是说，当client端调用Server端的一个方法的时候，需要等到对方的返回，才能继续执行client端，这个过程跟调用本地方法感觉上是一样的，这也是RMI的一个特点。
JMS 一般只是一个点发出一个Message到Message Server端，发出之后一般不会关心谁用了这个message。
一般RMI的应用是紧耦合，JMS的应用相对来说是松散耦合的应用。
***
 * RPC与RMI的区别
    * （1）RPC 跨语言，而 RMI只支持Java。
    *  (2）RMI 调用远程对象方法，允许方法返回 Java 对象以及基本数据类型，而RPC 不支持对象的概念，传送到 RPC 服务的消息由外部数据表示 (External Data Representation, XDR) 语言表示，这种语言抽象了字节序类和数据类型结构之间的差异。只有由 XDR 定义的数据类型才能被传递， 可以说 RMI 是面向对象方式的 Java RPC 。
    * （3）在方法调用上，RMI中，远程接口使每个远程方法都具有方法签名。如果一个方法在服务器上执行，但是没有相匹配的签名被添加到这个远程接口上，那么这个新方法就不能被RMI客户方所调用。在RPC中，当一个请求到达RPC服务器时，这个请求就包含了一个参数集和一个文本值，通常形成“classname.methodname”的形式。这就向RPC服务器表明，被请求的方法在为 “classname”的类中，名叫“methodname”。然后RPC服务器就去搜索与之相匹配的类和方法，并把它作为那种方法参数类型的输入。这里的参数类型是与RPC请求中的类型是匹配的。一旦匹配成功，这个方法就被调用了，其结果被编码后返回客户方。
***
 * Webservice与RMI的区别
    * （1）RMI是在tcp协议上传递可序列化的java对象，只能用在java虚拟机上，绑定语言，客户端和服务端都必须是java
    * （2）webservice没有这个限制，webservice是在http协议上传递xml文本文件，与语言和平台无关
***
 * Webservice与JMS的区别
    * （1）Webservice专注于远程服务调用，jms专注于信息交换。
    * （2）大多数情况下Webservice是两系统间的直接交互（Consumer <--> Producer），而大多数情况下jms是三方系统交互（Consumer <- Broker -> Producer）。当然，JMS也可以实现request-response模式的通信，只要Consumer或Producer其中一方兼任broker即可。
    * （3）JMS可以做到异步调用完全隔离了客户端和服务提供者，能够抵御流量洪峰； WebService服务通常为同步调用，需要有复杂的对象转换，相比SOAP，现在JSON，rest都是很好的http架构方案；（举一个例子，电子商务的分布式系统中，有支付系统和业务系统，支付系统负责用户付款，在用户在银行付款后需要通知各个业务系统，那么这个时候，既可以用同步也可以用异步，使用异步的好处就能抵御网站暂时的流量高峰，或者能应对慢消费者。
    * （4）JMS是java平台上的消息规范。一般jms消息不是一个xml，而是一个java对象，很明显，jms没考虑异构系统，说白了，JMS就没考虑非java的东西。但是好在现在大多数的jms provider（就是JMS的各种实现产品）都解决了异构问题。相比WebService的跨平台各有千秋吧。
***
版权声明：本文为腾讯云博主「黑泽君」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。
原文链接：！https://cloud.tencent.com/developer/article/1353191


